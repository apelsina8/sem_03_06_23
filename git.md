# Инструкция по работе с Git.

## Что такое Git?

_**Git**_ — это распределенная система контроля версий нашего кода. Зачем она нам? Для распределенных команд нужна какая-то система управления работы. Нужна, чтобы отслеживать изменения, которые происходят со временем. 

То есть шаг за шагом мы видим, какие файлы изменились и как. Особенно это важно, когда анализируешь, что было проделано в рамках одной задачи: это дает возможность возвращаться назад.


## Настройка Git.

У гита есть настройка пользователя, от которого будет идти работа. Это разумная и необходимая вещь, так как когда создается коммит, гит берет именно эту информацию для поля Author.

Чтобы настроить имя пользователя и пароль для всех проектов, нужно прописать следующие команды:

* git config --global user.name ”Ivan Ivanov”
* git config --global user.email ivan.ivanov@gmail.com

Если есть необходимость для конкретного проекта поменять автора (для личного проекта, например), можно убрать --global, и так получится:
 
* git config user.name ”Ivan Ivanov”
* git config user.email ivan.ivanov@gmail.com

## Что говорит Git? 

*Какие слова и действия?*

* гит репозиторий (git repository);
* коммит (commit);
* ветка (branch);
* смерджить (merge);
* конфликты (conflicts);
* спулить (pull);
* запушить (push);
* как игнорировать какие-то файлы (.gitignore).

И так далее.

*У Гита есть несколько состояний, которые нужно понять и запомнить:*

1. неотслеживаемое (untracked);
2. измененное (modified);
3. подготовленное (staged);
4. закомиченное (committed).

*Как их понимать?*

**1.** Это состояния, в которых находятся файлы из нашего кода. То есть, их жизненный путь обычно выглядит так:
Файл, который создан и не добавлен в репозиторий, будет в состоянии untracked.

**2.** Делаем изменения в файлах, которые уже добавлены в гит репозиторий — находятся в состоянии modified.

**3.** Из тех файлов, которые мы изменили, выбираем только те (или все), которые нужны нам (например, скомпилированные классы нам не нужны), и эти классы с изменениями попадают в состояние staged.

**4.** Из заготовленных файлов из состояния staged создается коммит и переходит уже в гит репозиторий. После этого staged состояние — пустое. А вот modified еще может что-то содержать.

## Основные команды.

Основные команды Git. 

__*git init*__ — инициализирует новый репозиторий GIT и начинает отслеживание существующего каталога. В существующий каталог добавляется скрытая вложенная папка, в которой размещается внутренняя структура данных, необходимая для управления версиями.

__*git clone*__ — создает локальную копию проекта, который уже существует удаленно. Клон включает в себя все файлы проекта, журнал и ветви.

__*git add*__ — подготавливает изменение. GIT отслеживает изменения в базе кода разработчика, но для включения изменений в журнал проекта необходимо подготавливать их и создавать моментальные снимки. Эта команда выполняет первую часть этого двухэтапного процесса, то есть подготовку. Все подготовленные изменения станут частью следующего моментального снимка и журнала проекта. Раздельные подготовка и фиксация дают разработчикам полный контроль над историей проекта без необходимости изменять подход к написанию кода и работе в целом.

__*git commit*__ — сохраняет моментальный снимок в журнале проекта и завершает процесс отслеживания изменений. Иначе говоря, фиксация похожа на создание фотографии. Все, что было подготовлено с помощью команды git add, станет частью моментального снимка при использовании git commit.

__*git status*__ — выводит состояние изменений: не отслеживаются, изменены или подготовлены.

__*git branch*__ — показывает ветви, с которыми ведется локальная работа.

__*git merge*__ — выполняет слияние линий разработки. Эта команда обычно применяется для объединения изменений, внесенных в двух разных ветвях. Например, разработчик выполняет слияние, когда необходимо объединить изменения из ветви функции с главной ветвью для развертывания.

__*git pull*__ — применяет к локальной линии разработки обновления из удаленного аналога. Разработчики используют эту команду, если коллега выполнил фиксации в ветви удаленного репозитория и эти изменения нужно отразить в локальной среде.

__*git push*__ — обновляет удаленный репозиторий с учетом фиксаций, выполненных в ветви локально.

## Начало работы с Git.

Можно работать и только с локальный репозиторием, и с удаленным.

Для отработки нужных команд можно воспользоваться только локальным репозиторием. Он хранит всю информацию только локально в проекте в папке .git.

Если говорить об удаленном, то вся информация хранится где-то на удаленном сервере: локально хранится только копия проекта, изменения которой можно запушить (git push) в удаленный репозиторий.

Чтобы создать локальный репозиторий, нужно написать:
1. git init

После этого будет создана папка .git в том месте, где находится консоль.

*.git* — это папка, которая хранит всю информацию о гит репозитории. Ее удалять не нужно 

Далее, добавляются файлы в этот проект, и их состояние становится Untracked. Чтобы посмотреть, какой статус работы на данный момент, пишем:

2. git status 

Мы находимся в master ветке, и пока мы не перейдем в другую, 
так все и останется.

Таким образом видно, какие файлы изменены, но еще не добавлены в состояние staged. Чтобы добавить их в состояние staged, нужно написать git add. Здесь может быть несколько вариантов, например:
* git add -A — добавить все файлы из состояния в staged;
* git add . — добавить все файлы из этой папки и все внутренних. По сути тоже самое, что и предыдущее;
* git add <имя файла> — добавляет только конкретный файл. Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону. Например, git add *.java: это значит, что нужно добавить только файлы с расширением java.

Далее пишем:
3. git add *.txt

Далее так же через команду git status проверяем отслеживание.

Теперь можем создать комит:
4. git commit -m "коментарий"

Далее есть отличная команда, чтобы посмотреть на историю коммитов в ветке - *git log*



## Что такое commit?

__*Коммит*__ — это основной объект в управлении контроля версий. Он содержит все изменения за время этого коммита. Коммиты связаны между с собой как односвязный список. 

А именно: 

Есть первый коммит. Когда создается второй коммит, то он (второй) знает, что идет после первого. И таким образом можно отследить информацию. 

Также у коммита есть еще своя информация, так называемые метаданные:
* уникальный идентификатор коммита, по которому можно его найти;
имя автора коммита, который создал его;
дата создания коммита;
комментарий, который описывает, что было сделано во время этого коммита.
Вот как это выглядит:

![commit](commit.jpg)

Для того, чтобы создать commit, нам необходимо указать к нему комментарий. Для этого используется "флажок" -m. Выглядит это так: __git commit -m__ "*какой-то комментарий*"

## Ветки. 

__*Ветка*__ — это указатель какого-то коммита. Так как коммит знает, какой коммит был до него, когда ветка указывает на какой-то коммит, к ней относятся и все те предыдущие. 

Исходя из этого можно сказать, что веток, указывающих на один и тот же коммит, может быть сколько угодно много.

Работа происходит в ветках, поэтому когда создается новый коммит, ветка переносит свой указатель на более новый коммит.

![схема веток](ветки.jpg)

## Как добавить изображение в Git.

Изображения в Git добавить очень просто. Для это необходимо:
* ![]() - в квадратных скобках мы пишем какое-то пояснение к изображению, а в круглых уже непосредственно имя самого файла и его разрешение, например, .jpg

Продолжаем работу с GitHub.

## Что такое GitHub?

__*GitHub*__ — крупнейший веб-сервис, который позволяет заниматься совместной разработкой с использованием Git и сохранять изменения на своих серверах.

## С чего начать?

Перед тем как мы начнём работу с сервисом GitHub, нам необходимо зарегестрироваться на сайте. Создать своб учётнуб запись.

Сервис позволяет сделать репозитории общедоступными или приватными, ограничить права кругу пользователей или кому-то одному, например, разрешить просматривать репозиторий, но не изменять в нём данные.

## Важная терминология.


__Форк (Fork)__ — собственное ответвление (fork) какого-то проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем пространстве имён, и вы сможете легко делать изменения путём отправки (push) изменений.

__Пул-реквест — pull request PR (пиар, он же merge request MR(мр))__ — предложение изменения кода в чужом репозитории. Допустим, вы забрали к себе чужой репозиторий, поработали с ним и теперь хотите, чтобы ваши изменения попали в оригинальный репозиторий — тогда вы создаёте создаёте PR с просьбой добавить ваши изменения в репозиторий.

__Репозиторий (repository)__ — директория проекта, который отслеживается Git. В директории хранится проект, история изменений и мета-информация проекта (в скрытой директории .git).

__Индекс__ — хранилка, где лежат имена файлов и их изменения, которые должны быть в следующем коммите. По факту индекс — просто файл. В индекс файлы сами не попадают, их нужно явно добавлять при помощи git add.

__Коммит (commit)__ — это фиксация изменений в истории проекта (изменения, которые внесены в индекс). Коммит хранит изменённые файлы, имя автора коммита и время, в которое был сделан коммит. Кроме того, каждый коммит имеет уникальный идентификатор, который позволяет в любое время к нему откатиться. Можете считать коммит этакой точкой сохранения.

__Ветка (branch)__ — последовательность коммитов. По сути — ссылка на последний коммит в этой ветке. Ветки не зависят друг от друга — можно вносить изменения в одну, и они не повлияют на другую (если вы явно этого не попросите). Работать вы начинаете в одной ветке — main, увидите чуть позже.

## Начинаем работу.

Репозитории, размещенные на gitHUB могут быть публичными — открытыми для скачивания всем желающим и приватными — доступными для скачивания только авторизованным пользователям, которым администратор репозитория выдал права. Для того, чтобы скачать репозиторий на локальную машину — нужно определить директорию, куда будет скачан проект и выполнить команду git clone [url], где url — это ссылка на удаленный репозиторий.

*Найти ссылку на репозиторий можно во вкладке Code.

Скачанный репозиторий будет иметь не только файлы проекта, но и директорию .git, где будут храниться все git-объекты, а значит вы можете также перемещаться по веткам и коммитам скачанного репозитория. Единственное, чтобы увидеть все удаленные ветки репозитория — необходимо применить команду git branch -r.

При скачивании удаленного репозитория git автоматически устанавливает связь между скачанным репозиторием и его удаленной версией поэтому обновлять локальный репозиторий теперь можно командой git pull, находясь в main ветке. Вы также можете загружать изменения внесенные в локальный репозиторий на удаленный сервер, если у вас есть соответствующие права.

Работая с чужим репозиторием, как правило, нужно создать свою отдельную ветку для работы. После чего, все изменения выгрузить и произвести pull request, чтобы предложить свои изменения владельцу репозитория. 

Так же GitHub предложит указать комментарий для получателя вашего запроса на слияние.

## Создаём новый репозиторий.

__1.__ Войдите на gitHUB и через иконку своего аккаунта перейдите в раздел «репозитории», там через кнопку «New» создайте новый репозиторий

__2.__ На следующем шаге необходимо задать имя репозиторию, указать его тип (публичный или приватный) и задать описание репозиторию -> нажимаем Create repository.

После успешного создания репозитория, вы увидите приветственную страницу с краткими, но очень полезными инструкциями. В них описано как синхронизировать удаленный и локальный репозитории.

Команды можно просто скопировать и ввести их в терминал в VSCode на своём компьютере. После этого вы сможете работать с удалённым репозиторием.

Все изменения, которые вы внесли, легко можно вывести в GitHub. Для этого существует специальная команды, о которой упоминалось ранее.
